CREATE SCHEMA IF NOT EXISTS config;
CREATE APPLICATION ROLE IF NOT EXISTS app_admin;
CREATE APPLICATION ROLE IF NOT EXISTS app_user;
CREATE SCHEMA IF NOT EXISTS app_public;
GRANT USAGE ON SCHEMA config TO APPLICATION ROLE app_admin;

GRANT USAGE ON SCHEMA app_public TO APPLICATION ROLE app_admin;
GRANT USAGE ON SCHEMA app_public TO APPLICATION ROLE app_user;
CREATE OR ALTER VERSIONED SCHEMA v1;
GRANT USAGE ON SCHEMA v1 TO APPLICATION ROLE app_admin;

-- Network rule and External Access Integration are created in start_application() procedure
-- after the application has been granted CREATE EXTERNAL ACCESS INTEGRATION privilege

-- Create schema for application data
CREATE SCHEMA IF NOT EXISTS app_data;
GRANT USAGE ON SCHEMA app_data TO APPLICATION ROLE app_admin;
GRANT USAGE ON SCHEMA app_data TO APPLICATION ROLE app_user;

-- =============================================================================
-- DATABASE MIGRATIONS
-- Auto-generated from Alembic migrations - DO NOT EDIT MANUALLY
-- Source: backend/alembic/versions/
-- Generated by: scripts/generate/generate_migrations_sql.py
-- =============================================================================
{{MIGRATIONS_SQL}}
-- =============================================================================

-- =============================================================================
-- MIGRATION PROCEDURES
-- =============================================================================

-- All migrations above use idempotent SQL (IF NOT EXISTS / IF EXISTS) so they
-- can be safely re-run on upgrades. The alembic_version table tracks which
-- migrations have been applied.

-- Procedure to get migration status
CREATE OR REPLACE PROCEDURE app_data.get_migration_status()
    RETURNS STRING
    LANGUAGE SQL
AS
$$
DECLARE
    applied_count NUMBER;
    versions_list VARCHAR DEFAULT '';
BEGIN
    -- Count applied migrations
    SELECT COUNT(*) INTO :applied_count FROM app_data.alembic_version;

    -- Get list of applied versions
    SELECT LISTAGG(version_num, ', ') WITHIN GROUP (ORDER BY version_num)
    INTO :versions_list
    FROM app_data.alembic_version;

    IF (applied_count = 0) THEN
        RETURN 'No migrations applied yet';
    ELSE
        RETURN 'Applied migrations (' || :applied_count || '): ' || :versions_list;
    END IF;
END;
$$;

GRANT USAGE ON PROCEDURE app_data.get_migration_status() TO APPLICATION ROLE app_admin;

-- Procedure to get pending migrations count (migrations in code but not applied)
-- This uses the expected migrations from the manifest embedded at build time
CREATE OR REPLACE PROCEDURE app_data.get_pending_migrations_count()
    RETURNS NUMBER
    LANGUAGE SQL
AS
$$
DECLARE
    applied_count NUMBER;
    expected_count NUMBER DEFAULT {{MIGRATIONS_COUNT}};
BEGIN
    SELECT COUNT(*) INTO :applied_count FROM app_data.alembic_version;
    RETURN :expected_count - :applied_count;
END;
$$;

GRANT USAGE ON PROCEDURE app_data.get_pending_migrations_count() TO APPLICATION ROLE app_admin;

-- Procedure to verify all migrations are applied
-- Returns 'OK' if all migrations applied, otherwise lists missing ones
CREATE OR REPLACE PROCEDURE app_data.verify_migrations()
    RETURNS STRING
    LANGUAGE SQL
AS
$$
DECLARE
    applied_count NUMBER;
    expected_count NUMBER DEFAULT {{MIGRATIONS_COUNT}};
    latest_version VARCHAR DEFAULT '{{LATEST_MIGRATION_VERSION}}';
    has_latest NUMBER;
BEGIN
    SELECT COUNT(*) INTO :applied_count FROM app_data.alembic_version;
    SELECT COUNT(*) INTO :has_latest FROM app_data.alembic_version WHERE version_num = :latest_version;

    IF (:applied_count >= :expected_count AND :has_latest > 0) THEN
        RETURN 'OK - All ' || :expected_count || ' migrations applied. Latest: ' || :latest_version;
    ELSE
        RETURN 'PENDING - Applied ' || :applied_count || ' of ' || :expected_count ||
               ' migrations. Latest expected: ' || :latest_version;
    END IF;
END;
$$;

GRANT USAGE ON PROCEDURE app_data.verify_migrations() TO APPLICATION ROLE app_admin;

-- Internal procedure with env_prefix parameter (use start_application wrapper instead)
CREATE OR REPLACE PROCEDURE app_public.start_application_internal(env_prefix VARCHAR)
    RETURNS string
    LANGUAGE sql
    AS $$
DECLARE
    migration_status VARCHAR;
    migration_verification VARCHAR;
    app_warehouse VARCHAR;
    poolname VARCHAR;
    eai_name VARCHAR;
    network_rule_name VARCHAR;
BEGIN
        -- Build resource names with optional environment prefix
        app_warehouse := CASE WHEN :env_prefix = '' THEN 'BLENDX_APP_WH' ELSE :env_prefix || '_BLENDX_APP_WH' END;
        poolname := CASE WHEN :env_prefix = '' THEN 'BLENDX_APP_COMPUTE_POOL' ELSE :env_prefix || '_BLENDX_APP_COMPUTE_POOL' END;
        eai_name := CASE WHEN :env_prefix = '' THEN 'blendx_serper_eai' ELSE :env_prefix || '_blendx_serper_eai' END;
        network_rule_name := CASE WHEN :env_prefix = '' THEN 'blendx_serper_network_rule' ELSE :env_prefix || '_blendx_serper_network_rule' END;

        -- Verify all migrations are applied (migrations are idempotent via setup.sql DDL)
        CALL app_data.verify_migrations() INTO :migration_verification;
        CALL app_data.get_migration_status() INTO :migration_status;

        -- First, create the application warehouse (unique name to avoid conflicts)
        CREATE WAREHOUSE IF NOT EXISTS IDENTIFIER(:app_warehouse)
            WAREHOUSE_SIZE = 'X-SMALL'
            AUTO_SUSPEND = 60
            AUTO_RESUME = TRUE
            INITIALLY_SUSPENDED = TRUE;

        -- Create compute pool if it doesn't exist
        EXECUTE IMMEDIATE 'CREATE COMPUTE POOL IF NOT EXISTS ' || poolname ||
            ' MIN_NODES = 1 MAX_NODES = 3 INSTANCE_FAMILY = CPU_X64_M AUTO_RESUME = TRUE AUTO_SUSPEND_SECS = 300';

        -- Create network rule for Serper API access (prefixed to avoid conflicts)
        EXECUTE IMMEDIATE 'CREATE NETWORK RULE IF NOT EXISTS app_public.' || network_rule_name ||
            ' TYPE = HOST_PORT VALUE_LIST = (''google.serper.dev'') MODE = EGRESS';

        -- Create external access integration for Serper API (prefixed to avoid conflicts)
        EXECUTE IMMEDIATE 'CREATE EXTERNAL ACCESS INTEGRATION IF NOT EXISTS ' || eai_name ||
            ' ALLOWED_NETWORK_RULES = (app_public.' || network_rule_name || ') ENABLED = TRUE';

        -- Create the service (prefixed to avoid conflicts)
        EXECUTE IMMEDIATE 'CREATE SERVICE app_public.blendx_st_spcs IN COMPUTE POOL ' || poolname ||
            ' FROM SPECIFICATION_FILE=''/fullstack.yaml'' QUERY_WAREHOUSE=' || app_warehouse ||
            ' EXTERNAL_ACCESS_INTEGRATIONS = (' || eai_name || ')';

        GRANT USAGE ON SERVICE app_public.blendx_st_spcs TO APPLICATION ROLE app_user;
        GRANT SERVICE ROLE app_public.blendx_st_spcs!ALL_ENDPOINTS_USAGE TO APPLICATION ROLE app_user;

        RETURN migration_verification || ' | ' || migration_status || '. Service started with pool ' || poolname || ', warehouse ' || app_warehouse || ' and EAI ' || eai_name || '. Check status, and when ready, get URL';
END;
$$;

GRANT USAGE ON PROCEDURE app_public.start_application_internal(VARCHAR) TO APPLICATION ROLE app_admin;

-- Public wrapper: start_application() - uses default resource names
CREATE OR REPLACE PROCEDURE app_public.start_application()
    RETURNS string
    LANGUAGE sql
    AS $$
DECLARE
    result VARCHAR;
BEGIN
    CALL app_public.start_application_internal('') INTO :result;
    RETURN result;
END;
$$;

GRANT USAGE ON PROCEDURE app_public.start_application() TO APPLICATION ROLE app_admin;

-- Public wrapper: start_application(env_prefix) - uses prefixed resource names
CREATE OR REPLACE PROCEDURE app_public.start_application_with_prefix(env_prefix VARCHAR)
    RETURNS string
    LANGUAGE sql
    AS $$
DECLARE
    result VARCHAR;
BEGIN
    CALL app_public.start_application_internal(:env_prefix) INTO :result;
    RETURN result;
END;
$$;

GRANT USAGE ON PROCEDURE app_public.start_application_with_prefix(VARCHAR) TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.stop_app()
    RETURNS string
    LANGUAGE sql
    AS
$$
BEGIN
    ALTER SERVICE app_public.blendx_st_spcs SUSPEND;
    RETURN 'Service suspended';
END
$$;
GRANT USAGE ON PROCEDURE app_public.stop_app() TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.resume_app()
    RETURNS string
    LANGUAGE sql
    AS
$$
BEGIN
    ALTER SERVICE app_public.blendx_st_spcs RESUME;
    RETURN 'Service resumed';
END
$$;
GRANT USAGE ON PROCEDURE app_public.resume_app() TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.update_service()
    RETURNS string
    LANGUAGE sql
    AS
$$
BEGIN
    -- Reload service from specification file to pick up new image tags
    ALTER SERVICE app_public.blendx_st_spcs FROM SPECIFICATION_FILE='/fullstack.yaml';
    RETURN 'Service updated with new specification';
END
$$;
GRANT USAGE ON PROCEDURE app_public.update_service() TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.destroy_app()
    RETURNS string
    LANGUAGE sql
    AS
$$
BEGIN
    DROP SERVICE IF EXISTS app_public.blendx_st_spcs;
    RETURN 'Service destroyed';
END
$$;
GRANT USAGE ON PROCEDURE app_public.destroy_app() TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.app_url()
    RETURNS string
    LANGUAGE sql
    AS
$$
BEGIN
    LET ingress_url VARCHAR;
    SHOW ENDPOINTS IN SERVICE app_public.blendx_st_spcs;
    SELECT "ingress_url" INTO :ingress_url FROM TABLE (RESULT_SCAN (LAST_QUERY_ID())) LIMIT 1;
    RETURN ingress_url;
END
$$;
GRANT USAGE ON PROCEDURE app_public.app_url() TO APPLICATION ROLE app_admin;
GRANT USAGE ON PROCEDURE app_public.app_url() TO APPLICATION ROLE app_user;

CREATE OR REPLACE PROCEDURE app_public.get_service_logs(container_name VARCHAR, num_lines NUMBER)
    RETURNS STRING
    LANGUAGE sql
    AS
$$
BEGIN
    RETURN SYSTEM$GET_SERVICE_LOGS('app_public.blendx_st_spcs', 0, :container_name, :num_lines);
END
$$;
GRANT USAGE ON PROCEDURE app_public.get_service_logs(VARCHAR, NUMBER) TO APPLICATION ROLE app_admin;

CREATE OR REPLACE PROCEDURE app_public.get_service_status()
    RETURNS STRING
    LANGUAGE sql
    AS
$$
BEGIN
    RETURN SYSTEM$GET_SERVICE_STATUS('app_public.blendx_st_spcs');
END
$$;
GRANT USAGE ON PROCEDURE app_public.get_service_status() TO APPLICATION ROLE app_admin;

-- Procedure to get the last execution result
CREATE OR REPLACE PROCEDURE app_public.get_last_crew_execution()
    RETURNS TABLE (
        id VARCHAR,
        execution_timestamp TIMESTAMP_NTZ,
        updated_at TIMESTAMP_NTZ,
        raw_output VARIANT,
        result_text TEXT,
        status VARCHAR,
        error_message TEXT,
        metadata VARIANT
    )
    LANGUAGE sql
    AS
$$
BEGIN
    LET result_cursor CURSOR FOR
        SELECT
            id,
            execution_timestamp,
            updated_at,
            raw_output,
            result_text,
            status,
            error_message,
            metadata
        FROM app_data.crew_execution_results
        ORDER BY execution_timestamp DESC
        LIMIT 1;
    OPEN result_cursor;
    RETURN TABLE(result_cursor);
END;
$$;
GRANT USAGE ON PROCEDURE app_public.get_last_crew_execution() TO APPLICATION ROLE app_admin;
GRANT USAGE ON PROCEDURE app_public.get_last_crew_execution() TO APPLICATION ROLE app_user;

-- Procedure to get recent executions (last N)
CREATE OR REPLACE PROCEDURE app_public.get_recent_crew_executions(num_results NUMBER)
    RETURNS TABLE (
        id VARCHAR,
        execution_timestamp TIMESTAMP_NTZ,
        updated_at TIMESTAMP_NTZ,
        raw_output VARIANT,
        result_text TEXT,
        status VARCHAR,
        error_message TEXT,
        metadata VARIANT
    )
    LANGUAGE sql
    AS
$$
BEGIN
    LET result_cursor CURSOR FOR
        SELECT
            id,
            execution_timestamp,
            updated_at,
            raw_output,
            result_text,
            status,
            error_message,
            metadata
        FROM app_data.crew_execution_results
        ORDER BY execution_timestamp DESC
        LIMIT :num_results;
    OPEN result_cursor;
    RETURN TABLE(result_cursor);
END;
$$;
GRANT USAGE ON PROCEDURE app_public.get_recent_crew_executions(NUMBER) TO APPLICATION ROLE app_admin;
GRANT USAGE ON PROCEDURE app_public.get_recent_crew_executions(NUMBER) TO APPLICATION ROLE app_user;

-- Procedure to count total crew executions
CREATE OR REPLACE PROCEDURE app_public.count_crew_executions()
    RETURNS NUMBER
    LANGUAGE sql
    AS
$$
BEGIN
    LET total_count NUMBER;
    SELECT COUNT(*) INTO :total_count FROM app_data.crew_execution_results;
    RETURN total_count;
END;
$$;
GRANT USAGE ON PROCEDURE app_public.count_crew_executions() TO APPLICATION ROLE app_admin;
GRANT USAGE ON PROCEDURE app_public.count_crew_executions() TO APPLICATION ROLE app_user;


CREATE OR REPLACE PROCEDURE config.get_config_for_ref(reference_name STRING)
  RETURNS VARCHAR
  LANGUAGE SQL
AS
$$
BEGIN
    CASE (UPPER(reference_name))
        WHEN 'SERPER_API_KEY' THEN
            RETURN '{"type": "CONFIGURATION", "payload": {"type": "GENERIC_STRING"}}';
        ELSE
            RETURN '{"type": "ERROR", "payload": {"message": "Unknown reference"}}';
    END CASE;
END;
$$;
GRANT USAGE ON PROCEDURE config.get_config_for_ref(STRING) TO APPLICATION ROLE app_admin;




CREATE OR REPLACE PROCEDURE CONFIG.REGISTER_SINGLE_REFERENCE(
  ref_name STRING, operation STRING, ref_or_alias STRING)
  RETURNS STRING
  LANGUAGE SQL
  AS $$
    DECLARE
      result STRING;
    BEGIN
      CASE (UPPER(operation))
        WHEN 'ADD' THEN
          result := SYSTEM$SET_REFERENCE(:ref_name, :ref_or_alias);
        WHEN 'REMOVE' THEN
          result := SYSTEM$REMOVE_REFERENCE(:ref_name);
        WHEN 'CLEAR' THEN
          result := SYSTEM$REMOVE_REFERENCE(:ref_name);
      ELSE
        RETURN 'unknown operation: ' || UPPER(operation);
      END CASE;
      RETURN 'Reference ' || :ref_name || ' ' || UPPER(:operation) || ' successful: ' || result;
    END;
  $$;

GRANT USAGE
  ON PROCEDURE CONFIG.REGISTER_SINGLE_REFERENCE(STRING, STRING, STRING)
  TO APPLICATION ROLE APP_ADMIN;
