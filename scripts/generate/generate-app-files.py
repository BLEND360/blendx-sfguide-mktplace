#!/usr/bin/env python3
"""
Generate application files from templates.
Replaces multiple sed commands with a single Python script.
"""

import argparse
import json
import re
import sys
from pathlib import Path


class GenerationError(Exception):
    """Raised when file generation fails."""
    pass


def replace_placeholders(content: str, replacements: dict) -> str:
    """Replace {{PLACEHOLDER}} with values."""
    for key, value in replacements.items():
        content = content.replace(f"{{{{{key}}}}}", value)
    return content


def validate_no_unresolved_placeholders(content: str, file_name: str) -> None:
    """Fail fast if any {{PLACEHOLDER}} remains unresolved."""
    unresolved = re.findall(r'\{\{([A-Z_][A-Z0-9_]*)\}\}', content)
    if unresolved:
        raise GenerationError(
            f"Unresolved placeholders in {file_name}: {', '.join(set(unresolved))}"
        )


def generate_from_template(
    template_path: str,
    output_path: str,
    replacements: dict,
    dry_run: bool = False
) -> str:
    """Generate a file from template with placeholder replacement."""
    with open(template_path, 'r') as f:
        content = f.read()

    result = replace_placeholders(content, replacements)
    validate_no_unresolved_placeholders(result, output_path)

    if dry_run:
        print(f"[DRY-RUN] Would generate {output_path}")
    else:
        with open(output_path, 'w') as f:
            f.write(result)
        print(f"Generated {output_path}")

    return result


def generate_setup_scripts(
    templates_dir: str,
    migrations_sql_path: str,
    migrations_manifest_path: str,
    output_dir: str,
    dry_run: bool = False
) -> None:
    """Generate setup.sql and modular setup scripts from templates."""
    import shutil

    # Read migrations SQL generated by generate_migrations_sql.py
    if not Path(migrations_sql_path).exists():
        raise GenerationError(
            f"Migrations SQL file not found: {migrations_sql_path}\n"
            "Run 'python scripts/generate/generate_migrations_sql.py' first to generate it."
        )

    # Read migrations manifest for metadata
    if not Path(migrations_manifest_path).exists():
        raise GenerationError(
            f"Migrations manifest not found: {migrations_manifest_path}\n"
            "Run 'python scripts/generate/generate_migrations_sql.py' first to generate it."
        )

    with open(migrations_sql_path, 'r') as f:
        migrations_sql = f.read()

    with open(migrations_manifest_path, 'r') as f:
        manifest = json.load(f)

    migrations_count = len(manifest.get('migrations', []))
    latest_version = manifest.get('latest_version', 'unknown')

    # Extract table names from migrations SQL for grants
    tables = sorted(set(re.findall(r'app_data\.([a-zA-Z_][a-zA-Z0-9_]*)', migrations_sql, re.IGNORECASE)))
    # Filter out alembic_version from grants (internal table)
    tables = [t for t in tables if t != 'alembic_version']

    if not tables:
        raise GenerationError(
            f"No table names extracted from {migrations_sql_path}. Check the SQL syntax."
        )

    # Generate grants for each table
    grants = []
    for table in tables:
        grants.append(f"""
-- Grant permissions for {table} table
GRANT SELECT ON TABLE app_data.{table} TO APPLICATION ROLE app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE app_data.{table} TO APPLICATION ROLE app_admin;""")

    full_migrations_content = migrations_sql + '\n' + '\n'.join(grants)

    # Create output setup directory
    scripts_setup_dir = Path(output_dir) / 'setup'
    if not dry_run:
        scripts_setup_dir.mkdir(parents=True, exist_ok=True)

    # Copy main setup.sql template
    main_template = Path(templates_dir) / 'setup_template.sql'
    main_output = Path(output_dir) / 'setup.sql'
    if dry_run:
        print(f"[DRY-RUN] Would copy {main_template} to {main_output}")
    else:
        shutil.copy(main_template, main_output)
        print(f"Generated {main_output}")

    # Process modular setup scripts
    setup_templates_dir = Path(templates_dir) / 'setup'
    setup_files = sorted(setup_templates_dir.glob('*.sql'))

    for template_file in setup_files:
        output_file = scripts_setup_dir / template_file.name

        with open(template_file, 'r') as f:
            content = f.read()

        # Replace placeholders if present
        if '{{MIGRATIONS_SQL}}' in content:
            content = content.replace('{{MIGRATIONS_SQL}}', full_migrations_content)
        if '{{MIGRATIONS_COUNT}}' in content:
            content = content.replace('{{MIGRATIONS_COUNT}}', str(migrations_count))
        if '{{LATEST_MIGRATION_VERSION}}' in content:
            content = content.replace('{{LATEST_MIGRATION_VERSION}}', latest_version)

        if dry_run:
            print(f"[DRY-RUN] Would generate {output_file}")
        else:
            with open(output_file, 'w') as f:
                f.write(content)
            print(f"Generated {output_file}")

    if not dry_run:
        print(f"Setup scripts generated with {len(tables)} table definitions: {', '.join(tables)}")
        print(f"  Migrations count: {migrations_count}, Latest version: {latest_version}")


def main():
    parser = argparse.ArgumentParser(description='Generate application files from templates')
    parser.add_argument('--image-tag', required=True, help='Docker image tag (SHA)')
    parser.add_argument('--output-dir', default='app/src', help='Output directory')
    parser.add_argument('--dry-run', action='store_true', help='Show what would be generated without writing files')

    args = parser.parse_args()

    # Ensure output directory exists (unless dry-run)
    output_dir = Path(args.output_dir)
    if not args.dry_run:
        output_dir.mkdir(parents=True, exist_ok=True)

    # Common replacements (database, schema, and image repo are now hardcoded in templates)
    replacements = {
        'IMAGE_TAG': args.image_tag,
    }

    mode = "[DRY-RUN] " if args.dry_run else ""
    print(f"{mode}Generating files with:")
    print(f"  Image Tag: {args.image_tag}")
    print()

    try:
        # Generate manifest.yml
        generate_from_template(
            'templates/manifest_template.yml',
            str(output_dir / 'manifest.yml'),
            replacements,
            dry_run=args.dry_run
        )

        # Generate fullstack.yaml
        generate_from_template(
            'templates/fullstack_template.yaml',
            str(output_dir / 'fullstack.yaml'),
            replacements,
            dry_run=args.dry_run
        )

        # Generate migrations SQL from Alembic migrations
        print("Generating migrations SQL from Alembic...")
        import subprocess
        result = subprocess.run(
            ['python3', 'scripts/generate/generate_migrations_sql.py'],
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            raise GenerationError(f"Failed to generate migrations SQL: {result.stderr}")
        print(result.stdout)

        # Generate setup.sql and modular setup scripts
        generate_setup_scripts(
            'templates',
            'scripts/generated/migrations/migrations.sql',
            'scripts/generated/migrations/migrations_manifest.json',
            str(output_dir),
            dry_run=args.dry_run
        )

        print()
        print(f"{mode}All files generated successfully!")

    except GenerationError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"ERROR: File not found: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
