name: Deploy to Production

on:
  push:
    tags:
      - 'release/*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (leave empty to auto-detect from STABLE)'
        required: false
        default: ''
      patch:
        description: 'Patch number to release (leave empty to auto-detect from STABLE)'
        required: false
        default: ''

env:
  SNOWFLAKE_CONNECTION: ${{ vars.SNOWFLAKE_CONNECTION }}

jobs:
  release-to-production:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify release tag is on main branch
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          git fetch origin main
          TAG="${GITHUB_REF#refs/tags/}"
          TAG_COMMIT=$(git rev-list -n 1 "$TAG")

          echo "Tag: $TAG"
          echo "Tag commit: $TAG_COMMIT"

          # Check if tag commit is on main branch
          if ! git merge-base --is-ancestor "$TAG_COMMIT" origin/main; then
            echo "::error::Release tag must be created from the main branch."
            exit 1
          fi

          echo "âœ“ Tag is on main branch"

      - name: Install Snowflake CLI
        uses: snowflakedb/snowflake-cli-action@v1.5
        with:
          cli-version: "3.6.0"

      - name: Setup Snowflake CLI PATH
        run: echo "$HOME/.snowflake-cli/bin" >> $GITHUB_PATH

      - name: Prepare Snowflake JWT key
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}" > snowflake_jwt_key.pem
          chmod 600 snowflake_jwt_key.pem

      - name: Configure Snowflake connection
        run: |
          snow connection add \
            --connection-name ${{ env.SNOWFLAKE_CONNECTION }} \
            --account ${{ secrets.SNOWFLAKE_ACCOUNT }} \
            --user ${{ vars.SNOWFLAKE_DEPLOY_USER }} \
            --role ${{ vars.SNOWFLAKE_DEPLOY_ROLE }} \
            --warehouse ${{ vars.SNOWFLAKE_WAREHOUSE }} \
            --database ${{ vars.SNOWFLAKE_DATABASE }} \
            --schema ${{ vars.SNOWFLAKE_SCHEMA }} \
            --host ${{ secrets.SNOWFLAKE_HOST }} \
            --port 443 \
            --authenticator SNOWFLAKE_JWT \
            --private-key-file snowflake_jwt_key.pem \
            --no-interactive

      - name: Test Snowflake connection
        run: snow connection test --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Validate release prerequisites
        run: |
          echo "=========================================="
          echo "Pre-release validation"
          echo "=========================================="

          # If manual override provided, skip STABLE validation
          if [ -n "${{ github.event.inputs.version }}" ] && [ -n "${{ github.event.inputs.patch }}" ]; then
            echo "Manual version override provided, skipping STABLE channel validation"
            echo "Version: ${{ github.event.inputs.version }}"
            echo "Patch: ${{ github.event.inputs.patch }}"
            exit 0
          fi

          # Verify application package exists and has at least one STABLE version
          STABLE_ROW=$(snow sql -q "
            USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }};
            SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};
          " --connection ${{ env.SNOWFLAKE_CONNECTION }} \
            | grep -i "| *STABLE *|" \
            | tail -1 || true)

          if [ -z "$STABLE_ROW" ]; then
            echo "::error::No versions found in STABLE release channel. Deploy to STABLE first."
            exit 1
          fi

          echo "STABLE release channel has at least one version"
          echo "Pre-release validation passed"

      - name: Auto-detect version and patch from STABLE channel
        id: detect_version
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PATCH="${{ github.event.inputs.patch }}"

          # If both version and patch are manually provided, use them directly
          if [ -n "$VERSION" ] && [ -n "$PATCH" ]; then
            echo "Using manually specified version: $VERSION patch $PATCH"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "patch=$PATCH" >> $GITHUB_OUTPUT

            echo "=========================================="
            echo "Release Configuration (Manual Override):"
            echo "  Version: $VERSION"
            echo "  Patch: $PATCH"
            echo "  Source: Manual input"
            echo "  Target Release Channel: DEFAULT"
            echo "=========================================="
            exit 0
          fi

          # Auto-detect from STABLE channel
          echo "Detecting latest version from STABLE channel..."

          VERSIONS_TABLE=$(snow sql -q "
            USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }};
            SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};
          " --connection ${{ env.SNOWFLAKE_CONNECTION }} 2>/dev/null || echo "")

          echo "Versions table:"
          echo "$VERSIONS_TABLE"

          # Find the latest STABLE version
          STABLE_ROW=$(echo "$VERSIONS_TABLE" | grep -i "| *STABLE *|" | tail -1)

          if [ -z "$STABLE_ROW" ]; then
            echo "::error::No versions found in STABLE release channel. Cannot promote to production."
            exit 1
          fi

          # Parse version and patch from pipe-separated format
          if [ -z "$VERSION" ]; then
            VERSION=$(echo "$STABLE_ROW" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2}')
            echo "Detected version from STABLE: $VERSION"
          fi

          if [ -z "$PATCH" ]; then
            PATCH=$(echo "$STABLE_ROW" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $3); print $3}')
            echo "Detected patch from STABLE: $PATCH"
          fi

          if [ -z "$VERSION" ] || [ -z "$PATCH" ]; then
            echo "::error::Unable to determine version or patch from STABLE"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

          echo "=========================================="
          echo "Release Configuration:"
          echo "  Version: $VERSION"
          echo "  Patch: $PATCH"
          echo "  Source Release Channel: STABLE"
          echo "  Target Release Channel: DEFAULT"
          echo "=========================================="

      - name: Guard - ensure STABLE has not advanced since tag
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "=========================================="
          echo "STABLE consistency guard"
          echo "=========================================="

          TAG_COMMIT=$(git rev-list -n 1 "${GITHUB_REF#refs/tags/}")
          TAG_TIME=$(git show -s --format=%ct "$TAG_COMMIT")

          echo "Tag commit: $TAG_COMMIT"
          echo "Tag timestamp: $TAG_TIME"

          # Get latest STABLE patch creation time
          STABLE_ROW=$(snow sql -q "
            USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }};
            SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};
          " --connection ${{ env.SNOWFLAKE_CONNECTION }} \
            | grep -i '| *STABLE *|' \
            | tail -1 || true)

          if [ -z "$STABLE_ROW" ]; then
            echo "::error::No STABLE versions found. Cannot promote to production."
            exit 1
          fi

          STABLE_CREATED_ON=$(echo "$STABLE_ROW" | awk -F'|' '{print $6}' | xargs)
          STABLE_TS=$(date -d "$STABLE_CREATED_ON" +%s 2>/dev/null || date -jf "%Y-%m-%d %H:%M:%S" "$STABLE_CREATED_ON" +%s)

          echo "Latest STABLE created_on: $STABLE_CREATED_ON"
          echo "Latest STABLE timestamp: $STABLE_TS"

          if [ "$STABLE_TS" -gt "$TAG_TIME" ]; then
            echo "::error::STABLE advanced after the release tag was created."
            echo "Re-create the tag from the latest approved state."
            exit 1
          fi

          echo "STABLE has not advanced since tag creation"

      - name: Verify version exists
        run: |
          VERSION="${{ steps.detect_version.outputs.version }}"
          PATCH="${{ steps.detect_version.outputs.patch }}"

          echo "Verifying version $VERSION patch $PATCH exists..."

          # Use JSON output for reliable parsing
          VERSIONS_JSON=$(snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} --format json 2>/dev/null) || VERSIONS_JSON="[]"

          VERSION_EXISTS=$(echo "$VERSIONS_JSON" | jq -r --arg v "$VERSION" '[flatten | .[] | select(.version != null) | select((.version | tostring | ascii_upcase) == ($v | ascii_upcase))] | length')

          if [ "$VERSION_EXISTS" -eq "0" ]; then
            echo "Error: Version ${VERSION} does not exist in package ${{ vars.SNOWFLAKE_APP_PACKAGE }}"
            echo ""
            echo "Available versions:"
            echo "$VERSIONS_JSON" | jq '.'
            exit 1
          fi

          echo "Version ${VERSION} exists"

      - name: Validate PROD release monotonicity
        run: |
          echo "Validating PROD release monotonicity..."

          VERSION="${{ steps.detect_version.outputs.version }}"
          PATCH="${{ steps.detect_version.outputs.patch }}"

          VERSIONS_JSON=$(snow sql -q "
          USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }};
          SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};
          " --connection ${{ env.SNOWFLAKE_CONNECTION }} --format json)

          CURRENT=$(echo "$VERSIONS_JSON" | jq -r '
            [flatten | .[] | select(.release_channel_names // "" | contains("DEFAULT"))]
            | sort_by(.created_on)
            | last // empty
          ')

          if [ -n "$CURRENT" ]; then
            CUR_VERSION=$(echo "$CURRENT" | jq -r '.version' | sed 's/V//')
            CUR_PATCH=$(echo "$CURRENT" | jq -r '.patch')

            NEW_VERSION=$(echo "$VERSION" | sed 's/V//')
            NEW_PATCH="$PATCH"

            echo "Current PROD: V$CUR_VERSION patch $CUR_PATCH"
            echo "New PROD:     V$NEW_VERSION patch $NEW_PATCH"

            if [ "$NEW_VERSION" -lt "$CUR_VERSION" ] || \
               { [ "$NEW_VERSION" -eq "$CUR_VERSION" ] && [ "$NEW_PATCH" -le "$CUR_PATCH" ]; }; then
              echo "::error::PROD release regression detected. Refusing to move production backwards."
              exit 1
            fi
          else
            echo "No existing PROD release found (first production release)."
          fi

      - name: Add version to DEFAULT release channel
        run: |
          VERSION="${{ steps.detect_version.outputs.version }}"

          CHANNEL_JSON=$(snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; SHOW RELEASE DIRECTIVES IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} --format json 2>/dev/null) || CHANNEL_JSON="[]"

          IN_DEFAULT=$(echo "$CHANNEL_JSON" | jq -r --arg v "$VERSION" '[flatten | .[] | select(.channel | ascii_upcase=="DEFAULT" and .version | ascii_upcase==($v|ascii_upcase))] | length')

          if [ "$IN_DEFAULT" -eq "0" ]; then
            echo "Adding version $VERSION to DEFAULT release channel..."
            snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL DEFAULT ADD VERSION ${VERSION};" --connection ${{ env.SNOWFLAKE_CONNECTION }}
          else
            echo "Version $VERSION already present in DEFAULT channel"
          fi

      - name: Set DEFAULT release directive
        run: |
          VERSION="${{ steps.detect_version.outputs.version }}"
          PATCH="${{ steps.detect_version.outputs.patch }}"

          echo "Setting DEFAULT release directive to version $VERSION patch $PATCH..."
          snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL DEFAULT SET DEFAULT RELEASE DIRECTIVE VERSION=${VERSION} PATCH=${PATCH};" --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Show current release status
        run: |
          echo ""
          echo "=========================================="
          echo "Current Release Status"
          echo "=========================================="

          echo ""
          echo "Versions:"
          snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};" --connection ${{ env.SNOWFLAKE_CONNECTION }}

          echo ""
          echo "Release Directives:"
          snow sql -q "USE ROLE ${{ vars.SNOWFLAKE_DEPLOY_ROLE }}; SHOW RELEASE DIRECTIVES IN APPLICATION PACKAGE ${{ vars.SNOWFLAKE_APP_PACKAGE }};" --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Summary
        run: |
          VERSION="${{ steps.detect_version.outputs.version }}"
          PATCH="${{ steps.detect_version.outputs.patch }}"

          echo ""
          echo "=========================================="
          echo "Production Release completed!"
          echo "=========================================="
          echo ""
          echo "Version $VERSION patch $PATCH has been promoted to the DEFAULT channel."
          echo ""
          echo "Next steps:"
          echo "  1. If not yet done, submit for security review in Provider Studio"
          echo "  2. Wait for Snowflake to approve the version (1-3 business days)"
          echo "  3. Once approved, the version will be available to marketplace consumers"
          echo ""
          echo "Provider Studio: https://app.snowflake.com > Provider Studio > Listings"
