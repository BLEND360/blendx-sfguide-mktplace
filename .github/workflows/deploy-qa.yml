name: Deploy to QA (develop)

on:
  push:
    branches:
      - develop
  workflow_dispatch:

env:
  BACKEND_IMAGE: eap_backend
  FRONTEND_IMAGE: eap_frontend
  ROUTER_IMAGE: eap_router

jobs:
  # ============================================
  # PARALLEL BUILD JOBS
  # ============================================
  build-backend:
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Snowflake CLI
        uses: snowflakedb/snowflake-cli-action@v2.0
        with:
          cli-version: "3.11"

      - name: Setup Snowflake CLI PATH
        run: echo "$HOME/.snowflake-cli/bin" >> $GITHUB_PATH

      - name: Prepare Snowflake JWT key
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}" > snowflake_jwt_key.pem
          chmod 600 snowflake_jwt_key.pem

      - name: Configure Snowflake connection
        run: |
          snow connection add \
            --connection-name mkt_blendx_demo \
            --account ${{ secrets.SNOWFLAKE_ACCOUNT }} \
            --user ${{ secrets.SNOWFLAKE_DEPLOY_USER }} \
            --role ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }} \
            --warehouse ${{ secrets.SNOWFLAKE_WAREHOUSE }} \
            --database ${{ secrets.SNOWFLAKE_DATABASE }} \
            --schema ${{ secrets.SNOWFLAKE_SCHEMA }} \
            --host ${{ secrets.SNOWFLAKE_HOST }} \
            --port 443 \
            --authenticator SNOWFLAKE_JWT \
            --private-key-file snowflake_jwt_key.pem \
            --no-interactive

      - name: Login to Snowflake Docker registry
        run: snow spcs image-registry login --connection mkt_blendx_demo

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64
          tags: ${{ secrets.SNOWFLAKE_REPO }}/${{ env.BACKEND_IMAGE }}:latest
          push: true
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

  build-frontend:
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Snowflake CLI
        uses: snowflakedb/snowflake-cli-action@v2.0
        with:
          cli-version: "3.11"

      - name: Setup Snowflake CLI PATH
        run: echo "$HOME/.snowflake-cli/bin" >> $GITHUB_PATH

      - name: Prepare Snowflake JWT key
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}" > snowflake_jwt_key.pem
          chmod 600 snowflake_jwt_key.pem

      - name: Configure Snowflake connection
        run: |
          snow connection add \
            --connection-name mkt_blendx_demo \
            --account ${{ secrets.SNOWFLAKE_ACCOUNT }} \
            --user ${{ secrets.SNOWFLAKE_DEPLOY_USER }} \
            --role ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }} \
            --warehouse ${{ secrets.SNOWFLAKE_WAREHOUSE }} \
            --database ${{ secrets.SNOWFLAKE_DATABASE }} \
            --schema ${{ secrets.SNOWFLAKE_SCHEMA }} \
            --host ${{ secrets.SNOWFLAKE_HOST }} \
            --port 443 \
            --authenticator SNOWFLAKE_JWT \
            --private-key-file snowflake_jwt_key.pem \
            --no-interactive

      - name: Login to Snowflake Docker registry
        run: snow spcs image-registry login --connection mkt_blendx_demo

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          tags: ${{ secrets.SNOWFLAKE_REPO }}/${{ env.FRONTEND_IMAGE }}:latest
          push: true
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend

  build-router:
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Snowflake CLI
        uses: snowflakedb/snowflake-cli-action@v2.0
        with:
          cli-version: "3.11"

      - name: Setup Snowflake CLI PATH
        run: echo "$HOME/.snowflake-cli/bin" >> $GITHUB_PATH

      - name: Prepare Snowflake JWT key
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}" > snowflake_jwt_key.pem
          chmod 600 snowflake_jwt_key.pem

      - name: Configure Snowflake connection
        run: |
          snow connection add \
            --connection-name mkt_blendx_demo \
            --account ${{ secrets.SNOWFLAKE_ACCOUNT }} \
            --user ${{ secrets.SNOWFLAKE_DEPLOY_USER }} \
            --role ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }} \
            --warehouse ${{ secrets.SNOWFLAKE_WAREHOUSE }} \
            --database ${{ secrets.SNOWFLAKE_DATABASE }} \
            --schema ${{ secrets.SNOWFLAKE_SCHEMA }} \
            --host ${{ secrets.SNOWFLAKE_HOST }} \
            --port 443 \
            --authenticator SNOWFLAKE_JWT \
            --private-key-file snowflake_jwt_key.pem \
            --no-interactive

      - name: Login to Snowflake Docker registry
        run: snow spcs image-registry login --connection mkt_blendx_demo

      - name: Build and push router image
        uses: docker/build-push-action@v5
        with:
          context: ./router
          platforms: linux/amd64
          tags: ${{ secrets.SNOWFLAKE_REPO }}/${{ env.ROUTER_IMAGE }}:latest
          push: true
          cache-from: type=gha,scope=router
          cache-to: type=gha,mode=max,scope=router

  # ============================================
  # DEPLOY JOB (runs after all builds complete)
  # ============================================
  deploy:
    runs-on: ubuntu-latest
    environment: qa
    needs: [build-backend, build-frontend, build-router]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version from git tag
        id: get_version
        run: |
          LATEST_TAG=$(git describe --tags --match "v*" --abbrev=0 2>/dev/null || echo "")

          if [ -n "$LATEST_TAG" ]; then
            VERSION=$(echo "$LATEST_TAG" | sed -E 's/^(v[0-9]+).*/\1/' | tr '[:lower:]' '[:upper:]')
            echo "Found git tag: $LATEST_TAG -> Using version: $VERSION"
          else
            VERSION="V1"
            echo "No git tag found. Using default version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Install Snowflake CLI
        uses: snowflakedb/snowflake-cli-action@v2.0
        with:
          cli-version: "3.11"

      - name: Setup Snowflake CLI PATH
        run: echo "$HOME/.snowflake-cli/bin" >> $GITHUB_PATH

      - name: Prepare Snowflake JWT key
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}" > snowflake_jwt_key.pem
          chmod 600 snowflake_jwt_key.pem

      - name: Configure Snowflake connection
        run: |
          snow connection add \
            --connection-name mkt_blendx_demo \
            --account ${{ secrets.SNOWFLAKE_ACCOUNT }} \
            --user ${{ secrets.SNOWFLAKE_DEPLOY_USER }} \
            --role ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }} \
            --warehouse ${{ secrets.SNOWFLAKE_WAREHOUSE }} \
            --database ${{ secrets.SNOWFLAKE_DATABASE }} \
            --schema ${{ secrets.SNOWFLAKE_SCHEMA }} \
            --host ${{ secrets.SNOWFLAKE_HOST }} \
            --port 443 \
            --authenticator SNOWFLAKE_JWT \
            --private-key-file snowflake_jwt_key.pem \
            --no-interactive

      - name: Test Snowflake connection
        run: snow connection test --connection mkt_blendx_demo

      - name: Generate manifest.yml and fullstack.yaml from templates
        run: |
          IMG_REPO=$(echo "${{ secrets.SNOWFLAKE_REPO }}" | awk -F'/' '{print $NF}')

          sed -e "s/{{SNOWFLAKE_DATABASE}}/${{ secrets.SNOWFLAKE_DATABASE }}/g" \
              -e "s/{{SNOWFLAKE_SCHEMA}}/${{ secrets.SNOWFLAKE_SCHEMA }}/g" \
              -e "s/{{SNOWFLAKE_IMG_REPO}}/${IMG_REPO}/g" \
              templates/manifest_template.yml > app/src/manifest.yml

          sed -e "s/{{SNOWFLAKE_DATABASE}}/${{ secrets.SNOWFLAKE_DATABASE }}/g" \
              -e "s/{{SNOWFLAKE_SCHEMA}}/${{ secrets.SNOWFLAKE_SCHEMA }}/g" \
              -e "s/{{SNOWFLAKE_IMG_REPO}}/${IMG_REPO}/g" \
              templates/fullstack_template.yaml > app/src/fullstack.yaml

          echo "Generated app/src/manifest.yml and app/src/fullstack.yaml with:"
          echo "  DATABASE: ${{ secrets.SNOWFLAKE_DATABASE }}"
          echo "  SCHEMA: ${{ secrets.SNOWFLAKE_SCHEMA }}"
          echo "  IMG_REPO: ${IMG_REPO}"

      - name: Generate setup.sql from template
        run: |
          python3 << 'EOF'
          import re

          with open('scripts/sql/tables_definitions.sql', 'r') as f:
              content = f.read()

          lines = [l for l in content.split('\n') if not l.strip().startswith('--')]
          table_defs = '\n'.join(lines)
          table_defs = table_defs.replace('CREATE TABLE IF NOT EXISTS ', 'CREATE OR REPLACE TABLE app_data.')

          tables = sorted(set(re.findall(r'app_data\.([a-z_]+)', table_defs)))
          grants = []
          for table in tables:
              grants.append(f"""
          -- Grant permissions for {table} table
          GRANT SELECT ON TABLE app_data.{table} TO APPLICATION ROLE app_user;
          GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE app_data.{table} TO APPLICATION ROLE app_admin;""")

          full_content = table_defs + '\n'.join(grants)

          with open('templates/setup_template.sql', 'r') as f:
              setup_content = f.read()

          setup_content = setup_content.replace('-- {{TABLE_DEFINITIONS}}', full_content)

          with open('app/src/setup.sql', 'w') as f:
              f.write(setup_content)

          print(f"Generated app/src/setup.sql with {len(tables)} table definitions: {', '.join(tables)}")
          EOF

      - name: Upload application files to Snowflake stage
        env:
          SNOWFLAKE_INSECURE_MODE: "true"
          REQUESTS_CA_BUNDLE: ""
          CURL_CA_BUNDLE: ""
        run: |
          snow sql --query "PUT file://${{ github.workspace }}/app/src/* @${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage AUTO_COMPRESS=FALSE OVERWRITE=TRUE;" --connection mkt_blendx_demo

      - name: Create Application Package if not exists
        run: |
          echo "Creating Application Package ${{ secrets.SNOWFLAKE_APP_PACKAGE }} if it doesn't exist..."
          snow sql -q "CREATE APPLICATION PACKAGE IF NOT EXISTS ${{ secrets.SNOWFLAKE_APP_PACKAGE }} DISTRIBUTION = INTERNAL;" --connection mkt_blendx_demo

          echo "Creating QA release channel if it doesn't exist..."
          snow sql -q "ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} ADD RELEASE CHANNEL QA;" --connection mkt_blendx_demo || echo "QA channel may already exist (OK)"

      - name: Clean up old versions not in release channel
        run: |
          echo "Using version: $VERSION"
          echo "Checking for old versions not in any release channel..."

          TEMP_VERSIONS=$(mktemp)
          snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" --connection mkt_blendx_demo > "$TEMP_VERSIONS" 2>&1 || true

          ORPHAN_VERSIONS=$(cat "$TEMP_VERSIONS" | \
              grep -E "^\|[[:space:]]*V[0-9]+" | \
              grep -i "None" | \
              awk -F'|' '{print $2}' | \
              tr -d ' ' | \
              grep -v "^${VERSION}$" || echo "")

          rm -f "$TEMP_VERSIONS"

          if [ -n "$ORPHAN_VERSIONS" ]; then
              echo "Found versions not in any release channel: $ORPHAN_VERSIONS"
              for ORPHAN_VERSION in $ORPHAN_VERSIONS; do
                  if [ -n "$ORPHAN_VERSION" ] && [ "$ORPHAN_VERSION" != "${VERSION}" ]; then
                      echo "Deregistering version $ORPHAN_VERSION..."
                      snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} DEREGISTER VERSION ${ORPHAN_VERSION};" --connection mkt_blendx_demo || echo "Could not deregister $ORPHAN_VERSION (OK)"
                  fi
              done
          else
              echo "No orphan versions found to deregister."
          fi

      - name: Register version or add patch
        run: |
          VERSION_EXISTS=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" --connection mkt_blendx_demo 2>&1 | grep -i "| ${VERSION} " | wc -l | tr -d ' ' || echo "0")

          if [ "$VERSION_EXISTS" -gt "0" ]; then
            echo "Version ${VERSION} exists. Adding patch..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} ADD PATCH FOR VERSION ${VERSION} USING '@${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage';" --connection mkt_blendx_demo
          else
            echo "Version ${VERSION} does not exist. Registering new version..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} REGISTER VERSION ${VERSION} USING @${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage;" --connection mkt_blendx_demo
          fi

      - name: Get latest patch number
        id: get_patch
        run: |
          LATEST_PATCH=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" --connection mkt_blendx_demo 2>&1 | grep -i "| ${VERSION} " | awk -F'|' '{print $3}' | tr -d ' ' | sort -n | tail -1 || echo "0")

          if [ -z "$LATEST_PATCH" ] || ! [[ "$LATEST_PATCH" =~ ^[0-9]+$ ]]; then
            LATEST_PATCH=0
          fi

          echo "Latest patch: $LATEST_PATCH"
          echo "patch=$LATEST_PATCH" >> $GITHUB_OUTPUT

      - name: Update QA release channel
        run: |
          PATCH="${{ steps.get_patch.outputs.patch }}"

          snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL QA ADD VERSION ${VERSION};" --connection mkt_blendx_demo 2>&1 || echo "Version may already be in QA channel (OK)"

          snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL QA SET DEFAULT RELEASE DIRECTIVE VERSION=${VERSION} PATCH=${PATCH};" --connection mkt_blendx_demo

      - name: Upgrade and restart QA application
        run: |
          set +e  # Don't exit on error
          PATCH="${{ steps.get_patch.outputs.patch }}"

          echo "Checking for application ${{ secrets.SNOWFLAKE_APP_INSTANCE }}..."
          APP_OUTPUT=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; SHOW APPLICATIONS LIKE '${{ secrets.SNOWFLAKE_APP_INSTANCE }}';" --connection mkt_blendx_demo 2>&1)
          SQL_EXIT_CODE=$?
          echo "SHOW APPLICATIONS output (exit code: $SQL_EXIT_CODE):"
          echo "$APP_OUTPUT"

          # Check if command failed or returned 0 rows
          if [ $SQL_EXIT_CODE -ne 0 ]; then
            echo "SQL command failed with exit code $SQL_EXIT_CODE"
            APP_EXISTS=0
          elif echo "$APP_OUTPUT" | grep -q "0 Row"; then
            echo "No application found (0 Row in output)"
            APP_EXISTS=0
          else
            echo "Application found"
            APP_EXISTS=1
          fi

          echo "APP_EXISTS=$APP_EXISTS"
          set -e  # Re-enable exit on error

          if [ "$APP_EXISTS" -gt "0" ]; then
            echo "Application exists. Upgrading application package..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; ALTER APPLICATION ${{ secrets.SNOWFLAKE_APP_INSTANCE }} UPGRADE USING VERSION ${VERSION} PATCH ${PATCH};" --connection mkt_blendx_demo || echo "Upgrade not needed or failed (OK)"

            echo "Restarting service with force pull..."
            export SNOWFLAKE_ROLE="${{ secrets.SNOWFLAKE_ROLE }}"
            export SNOWFLAKE_APP_INSTANCE="${{ secrets.SNOWFLAKE_APP_INSTANCE }}"
            export SNOWFLAKE_COMPUTE_POOL="${{ secrets.SNOWFLAKE_COMPUTE_POOL }}"
            export SNOWFLAKE_CONNECTION="mkt_blendx_demo"
            chmod +x scripts/restart.sh
            ./scripts/restart.sh
          else
            echo "::warning::Application does not exist. Please run setup/create-application.sh to install the application first."
            echo "Skipping upgrade and restart."
          fi

      - name: Wait for service to be ready
        run: |
          echo "Waiting 60 seconds for service to be fully ready..."
          sleep 60

      - name: Get Application URL
        id: get_url
        run: |
          set +e  # Don't exit on error
          APP_OUTPUT=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; SHOW APPLICATIONS LIKE '${{ secrets.SNOWFLAKE_APP_INSTANCE }}';" --connection mkt_blendx_demo 2>&1)
          SQL_EXIT_CODE=$?

          if [ $SQL_EXIT_CODE -ne 0 ] || echo "$APP_OUTPUT" | grep -q "0 Row"; then
            echo "Application not found or error occurred"
          else
            echo "=========================================="
            echo "SERVICE STATUS"
            echo "=========================================="
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; CALL ${{ secrets.SNOWFLAKE_APP_INSTANCE }}.app_public.get_service_status();" --connection mkt_blendx_demo || echo "Could not get service status"

            echo ""
            echo "=========================================="
            echo "APPLICATION URL"
            echo "=========================================="
            URL_OUTPUT=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; CALL ${{ secrets.SNOWFLAKE_APP_INSTANCE }}.app_public.app_url();" --connection mkt_blendx_demo 2>&1)
            echo "Raw URL output:"
            echo "$URL_OUTPUT"
            APP_URL=$(echo "$URL_OUTPUT" | grep -oE 'https://[^[:space:]|"]+' | head -1 || echo "")
            if [ -z "$APP_URL" ]; then
              APP_URL="URL not available yet"
            fi
            echo "ðŸš€ $APP_URL"
            echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          fi
          exit 0  # Always succeed

      - name: Summary
        run: |
          echo "=========================================="
          echo "QA Deployment completed!"
          echo "=========================================="
          echo "Version $VERSION patch ${{ steps.get_patch.outputs.patch }} deployed to QA channel"
          echo ""
          echo "ðŸš€ Application URL: ${{ steps.get_url.outputs.app_url }}"
          echo ""
          echo "The QA application will automatically receive updates through the QA release channel."
