name: Deploy to QA (develop)

on:
  push:
    branches:
      - develop
  workflow_dispatch:

env:
  BACKEND_IMAGE: eap_backend
  FRONTEND_IMAGE: eap_frontend
  ROUTER_IMAGE: eap_router
  SNOWFLAKE_CONNECTION: mkt_blendx_demo

jobs:
  # ============================================
  # VALIDATE
  # ============================================
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate YAML templates
        run: |
          echo "Validating YAML files..."
          python3 -c "
          import yaml
          import sys
          files = ['templates/manifest_template.yml', 'templates/fullstack_template.yaml']
          errors = []
          for f in files:
              try:
                  with open(f) as fh:
                      yaml.safe_load(fh)
                  print(f'OK: {f}')
              except Exception as e:
                  errors.append(f'{f}: {e}')
                  print(f'FAIL: {f}: {e}')
          if errors:
              sys.exit(1)
          "

      - name: Validate SQL syntax (basic)
        run: |
          echo "Checking SQL files for basic syntax..."
          for f in scripts/sql/*.sql templates/*.sql; do
            if [ -f "$f" ]; then
              # Check for unclosed parentheses, missing semicolons at end
              if grep -qE "^[^-]*\([^)]*$" "$f" 2>/dev/null; then
                echo "WARNING: Possible unclosed parenthesis in $f"
              fi
              echo "OK: $f"
            fi
          done

  # ============================================
  # DETECT CHANGES
  # ============================================
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      router: ${{ steps.filter.outputs.router }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect changed paths
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'
            router:
              - 'router/**'

  # ============================================
  # PARALLEL BUILD JOBS
  # ============================================
  build-backend:
    needs: [detect-changes, validate]
    if: ${{ needs.detect-changes.outputs.backend == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment: qa
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Snowflake
        uses: ./.github/actions/snowflake-setup
        with:
          private-key: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}
          account: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          user: ${{ secrets.SNOWFLAKE_DEPLOY_USER }}
          role: ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}
          warehouse: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          database: ${{ secrets.SNOWFLAKE_DATABASE }}
          schema: ${{ secrets.SNOWFLAKE_SCHEMA }}
          host: ${{ secrets.SNOWFLAKE_HOST }}

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "tags=${{ secrets.SNOWFLAKE_REPO }}/${{ env.BACKEND_IMAGE }}:$SHORT_SHA,${{ secrets.SNOWFLAKE_REPO }}/${{ env.BACKEND_IMAGE }}:latest" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          push: true
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

  build-frontend:
    needs: [detect-changes, validate]
    if: ${{ needs.detect-changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment: qa
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Snowflake
        uses: ./.github/actions/snowflake-setup
        with:
          private-key: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}
          account: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          user: ${{ secrets.SNOWFLAKE_DEPLOY_USER }}
          role: ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}
          warehouse: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          database: ${{ secrets.SNOWFLAKE_DATABASE }}
          schema: ${{ secrets.SNOWFLAKE_SCHEMA }}
          host: ${{ secrets.SNOWFLAKE_HOST }}

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "tags=${{ secrets.SNOWFLAKE_REPO }}/${{ env.FRONTEND_IMAGE }}:$SHORT_SHA,${{ secrets.SNOWFLAKE_REPO }}/${{ env.FRONTEND_IMAGE }}:latest" >> $GITHUB_OUTPUT

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          push: true
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend

  build-router:
    needs: [detect-changes, validate]
    if: ${{ needs.detect-changes.outputs.router == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment: qa
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Snowflake
        uses: ./.github/actions/snowflake-setup
        with:
          private-key: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}
          account: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          user: ${{ secrets.SNOWFLAKE_DEPLOY_USER }}
          role: ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}
          warehouse: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          database: ${{ secrets.SNOWFLAKE_DATABASE }}
          schema: ${{ secrets.SNOWFLAKE_SCHEMA }}
          host: ${{ secrets.SNOWFLAKE_HOST }}

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "tags=${{ secrets.SNOWFLAKE_REPO }}/${{ env.ROUTER_IMAGE }}:$SHORT_SHA,${{ secrets.SNOWFLAKE_REPO }}/${{ env.ROUTER_IMAGE }}:latest" >> $GITHUB_OUTPUT

      - name: Build and push router image
        uses: docker/build-push-action@v5
        with:
          context: ./router
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          push: true
          cache-from: type=gha,scope=router
          cache-to: type=gha,mode=max,scope=router

  # ============================================
  # DEPLOY JOB (runs after all builds complete)
  # ============================================
  deploy:
    runs-on: ubuntu-latest
    environment: qa
    needs: [detect-changes, build-backend, build-frontend, build-router]
    if: |
      always() &&
      (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') &&
      (needs.build-router.result == 'success' || needs.build-router.result == 'skipped') &&
      !(needs.build-backend.result == 'failure' || needs.build-frontend.result == 'failure' || needs.build-router.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version from git tag
        id: version
        run: |
          LATEST_TAG=$(git describe --tags --match "v*" --abbrev=0 2>/dev/null || echo "")
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          if [ -n "$LATEST_TAG" ]; then
            VERSION=$(echo "$LATEST_TAG" | sed -E 's/^(v[0-9]+).*/\1/' | tr '[:lower:]' '[:upper:]')
            echo "Found git tag: $LATEST_TAG -> Using version: $VERSION"
          else
            VERSION="V1"
            echo "No git tag found. Using default version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Setup Snowflake
        uses: ./.github/actions/snowflake-setup
        with:
          private-key: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_RAW }}
          account: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          user: ${{ secrets.SNOWFLAKE_DEPLOY_USER }}
          role: ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}
          warehouse: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          database: ${{ secrets.SNOWFLAKE_DATABASE }}
          schema: ${{ secrets.SNOWFLAKE_SCHEMA }}
          host: ${{ secrets.SNOWFLAKE_HOST }}
          login-registry: 'false'

      - name: Test Snowflake connection
        run: snow connection test --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Generate manifest.yml and fullstack.yaml from templates
        run: |
          IMG_REPO=$(echo "${{ secrets.SNOWFLAKE_REPO }}" | awk -F'/' '{print $NF}')

          sed -e "s/{{SNOWFLAKE_DATABASE}}/${{ secrets.SNOWFLAKE_DATABASE }}/g" \
              -e "s/{{SNOWFLAKE_SCHEMA}}/${{ secrets.SNOWFLAKE_SCHEMA }}/g" \
              -e "s/{{SNOWFLAKE_IMG_REPO}}/${IMG_REPO}/g" \
              templates/manifest_template.yml > app/src/manifest.yml

          sed -e "s/{{SNOWFLAKE_DATABASE}}/${{ secrets.SNOWFLAKE_DATABASE }}/g" \
              -e "s/{{SNOWFLAKE_SCHEMA}}/${{ secrets.SNOWFLAKE_SCHEMA }}/g" \
              -e "s/{{SNOWFLAKE_IMG_REPO}}/${IMG_REPO}/g" \
              templates/fullstack_template.yaml > app/src/fullstack.yaml

          echo "Generated app/src/manifest.yml and app/src/fullstack.yaml"

      - name: Generate setup.sql from template
        run: |
          python3 << 'EOF'
          import re

          with open('scripts/sql/tables_definitions.sql', 'r') as f:
              content = f.read()

          lines = [l for l in content.split('\n') if not l.strip().startswith('--')]
          table_defs = '\n'.join(lines)
          table_defs = table_defs.replace('CREATE TABLE IF NOT EXISTS ', 'CREATE OR REPLACE TABLE app_data.')

          tables = sorted(set(re.findall(r'app_data\.([a-z_]+)', table_defs)))
          grants = []
          for table in tables:
              grants.append(f"""
          -- Grant permissions for {table} table
          GRANT SELECT ON TABLE app_data.{table} TO APPLICATION ROLE app_user;
          GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE app_data.{table} TO APPLICATION ROLE app_admin;""")

          full_content = table_defs + '\n'.join(grants)

          with open('templates/setup_template.sql', 'r') as f:
              setup_content = f.read()

          setup_content = setup_content.replace('-- {{TABLE_DEFINITIONS}}', full_content)

          with open('app/src/setup.sql', 'w') as f:
              f.write(setup_content)

          print(f"Generated app/src/setup.sql with {len(tables)} table definitions")
          EOF

      - name: Upload application files to Snowflake stage
        env:
          SNOWFLAKE_INSECURE_MODE: "true"
          REQUESTS_CA_BUNDLE: ""
          CURL_CA_BUNDLE: ""
        run: |
          snow sql --query "PUT file://${{ github.workspace }}/app/src/* @${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage AUTO_COMPRESS=FALSE OVERWRITE=TRUE;" --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Create Application Package if not exists
        run: |
          echo "Creating Application Package ${{ secrets.SNOWFLAKE_APP_PACKAGE }} if it doesn't exist..."
          snow sql -q "CREATE APPLICATION PACKAGE IF NOT EXISTS ${{ secrets.SNOWFLAKE_APP_PACKAGE }} DISTRIBUTION = INTERNAL;" --connection ${{ env.SNOWFLAKE_CONNECTION }}

          echo "Creating QA release channel if it doesn't exist..."
          snow sql -q "ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} ADD RELEASE CHANNEL QA;" --connection ${{ env.SNOWFLAKE_CONNECTION }} || echo "QA channel may already exist"

      - name: Clean up old versions not in release channel
        run: |
          echo "Checking for orphan versions..."

          # Get versions as JSON for more reliable parsing
          VERSIONS_JSON=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} -o json 2>/dev/null) || VERSIONS_JSON="[]"

          # Parse with Python for reliability
          python3 << EOF
          import json
          import subprocess
          import os

          current_version = os.environ.get('VERSION', 'V1')
          connection = '${{ env.SNOWFLAKE_CONNECTION }}'
          app_package = '${{ secrets.SNOWFLAKE_APP_PACKAGE }}'
          role = '${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}'

          try:
              versions = json.loads('''$VERSIONS_JSON''')
              orphans = [v.get('version', '') for v in versions
                        if v.get('release_channel') in [None, 'None', '']
                        and v.get('version', '') != current_version]

              for orphan in orphans:
                  if orphan:
                      print(f"Deregistering orphan version: {orphan}")
                      subprocess.run([
                          'snow', 'sql', '-q',
                          f"USE ROLE {role}; ALTER APPLICATION PACKAGE {app_package} DEREGISTER VERSION {orphan};",
                          '--connection', connection
                      ], capture_output=True)
          except Exception as e:
              print(f"Could not parse versions (OK): {e}")
          EOF

      - name: Register version or add patch
        id: register
        run: |
          # Check if version exists using JSON output
          VERSION_CHECK=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} -o json 2>/dev/null) || VERSION_CHECK="[]"

          VERSION_EXISTS=$(echo "$VERSION_CHECK" | python3 -c "
          import json, sys
          versions = json.load(sys.stdin)
          exists = any(v.get('version') == '$VERSION' for v in versions)
          print('1' if exists else '0')
          " 2>/dev/null || echo "0")

          if [ "$VERSION_EXISTS" = "1" ]; then
            echo "Version ${VERSION} exists. Adding patch..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} ADD PATCH FOR VERSION ${VERSION} USING '@${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage';" --connection ${{ env.SNOWFLAKE_CONNECTION }}
          else
            echo "Version ${VERSION} does not exist. Registering new version..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} REGISTER VERSION ${VERSION} USING @${{ secrets.SNOWFLAKE_DATABASE }}.${{ secrets.SNOWFLAKE_SCHEMA }}.app_stage;" --connection ${{ env.SNOWFLAKE_CONNECTION }}
          fi

      - name: Get latest patch number
        id: patch
        run: |
          VERSIONS_JSON=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; SHOW VERSIONS IN APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} -o json 2>/dev/null) || VERSIONS_JSON="[]"

          LATEST_PATCH=$(echo "$VERSIONS_JSON" | python3 -c "
          import json, sys
          versions = json.load(sys.stdin)
          patches = [int(v.get('patch', 0)) for v in versions if v.get('version') == '$VERSION']
          print(max(patches) if patches else 0)
          " 2>/dev/null || echo "0")

          echo "Latest patch: $LATEST_PATCH"
          echo "patch=$LATEST_PATCH" >> $GITHUB_OUTPUT

      - name: Update QA release channel
        run: |
          PATCH="${{ steps.patch.outputs.patch }}"

          snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL QA ADD VERSION ${VERSION};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} 2>&1 || echo "Version may already be in QA channel"

          snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_DEPLOY_ROLE }}; ALTER APPLICATION PACKAGE ${{ secrets.SNOWFLAKE_APP_PACKAGE }} MODIFY RELEASE CHANNEL QA SET DEFAULT RELEASE DIRECTIVE VERSION=${VERSION} PATCH=${PATCH};" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }}

      - name: Upgrade and restart QA application
        run: |
          set +e
          PATCH="${{ steps.patch.outputs.patch }}"

          echo "Checking for application ${{ secrets.SNOWFLAKE_APP_INSTANCE }}..."
          APP_CHECK=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; SHOW APPLICATIONS LIKE '${{ secrets.SNOWFLAKE_APP_INSTANCE }}';" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} -o json 2>/dev/null) || APP_CHECK="[]"

          APP_EXISTS=$(echo "$APP_CHECK" | python3 -c "import json,sys; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")

          set -e

          if [ "$APP_EXISTS" -gt "0" ]; then
            echo "Application exists. Upgrading..."
            snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; ALTER APPLICATION ${{ secrets.SNOWFLAKE_APP_INSTANCE }} UPGRADE USING VERSION ${VERSION} PATCH ${PATCH};" \
              --connection ${{ env.SNOWFLAKE_CONNECTION }} || echo "Upgrade not needed"

            echo "Restarting service with force pull..."
            export SNOWFLAKE_ROLE="${{ secrets.SNOWFLAKE_ROLE }}"
            export SNOWFLAKE_APP_INSTANCE="${{ secrets.SNOWFLAKE_APP_INSTANCE }}"
            export SNOWFLAKE_COMPUTE_POOL="${{ secrets.SNOWFLAKE_COMPUTE_POOL }}"
            export SNOWFLAKE_CONNECTION="${{ env.SNOWFLAKE_CONNECTION }}"
            chmod +x scripts/manage-service.sh
            ./scripts/manage-service.sh
          else
            echo "::warning::Application does not exist. Run setup/create-application.sh first."
          fi

      - name: Wait for service to be ready
        run: |
          export SNOWFLAKE_ROLE="${{ secrets.SNOWFLAKE_ROLE }}"
          export SNOWFLAKE_APP_INSTANCE="${{ secrets.SNOWFLAKE_APP_INSTANCE }}"
          export SNOWFLAKE_CONNECTION="${{ env.SNOWFLAKE_CONNECTION }}"
          export MAX_ATTEMPTS=20
          chmod +x scripts/wait-for-service.sh
          ./scripts/wait-for-service.sh

      - name: Get Application URL
        id: url
        run: |
          set +e
          URL_OUTPUT=$(snow sql -q "USE ROLE ${{ secrets.SNOWFLAKE_ROLE }}; CALL ${{ secrets.SNOWFLAKE_APP_INSTANCE }}.app_public.app_url();" \
            --connection ${{ env.SNOWFLAKE_CONNECTION }} 2>&1)

          APP_URL=$(echo "$URL_OUTPUT" | grep -oE 'https://[^[:space:]|"]+' | head -1 || echo "")
          if [ -z "$APP_URL" ]; then
            DOMAIN=$(echo "$URL_OUTPUT" | grep -oE '[a-zA-Z0-9-]+\.snowflakecomputing\.app' | head -1 || echo "")
            if [ -n "$DOMAIN" ]; then
              APP_URL="https://${DOMAIN}"
            else
              APP_URL="URL not available yet"
            fi
          fi
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT

      - name: Deploy Summary
        run: |
          echo ""
          echo "=========================================="
          echo "         QA DEPLOYMENT SUMMARY"
          echo "=========================================="
          echo ""
          echo "Git Info:"
          echo "  Commit:     ${{ github.sha }}"
          echo "  Short SHA:  ${{ steps.version.outputs.short_sha }}"
          echo "  Branch:     ${{ github.ref_name }}"
          echo ""
          echo "Snowflake App:"
          echo "  Package:    ${{ secrets.SNOWFLAKE_APP_PACKAGE }}"
          echo "  Instance:   ${{ secrets.SNOWFLAKE_APP_INSTANCE }}"
          echo "  Version:    ${{ steps.version.outputs.version }}"
          echo "  Patch:      ${{ steps.patch.outputs.patch }}"
          echo "  Channel:    QA"
          echo ""
          echo "Infrastructure:"
          echo "  Database:   ${{ secrets.SNOWFLAKE_DATABASE }}"
          echo "  Schema:     ${{ secrets.SNOWFLAKE_SCHEMA }}"
          echo "  Pool:       ${{ secrets.SNOWFLAKE_COMPUTE_POOL }}"
          echo ""
          echo "Images Built:"
          echo "  Backend:    ${{ needs.build-backend.result }}"
          echo "  Frontend:   ${{ needs.build-frontend.result }}"
          echo "  Router:     ${{ needs.build-router.result }}"
          echo ""
          echo "=========================================="
          echo "  Application URL: ${{ steps.url.outputs.app_url }}"
          echo "=========================================="
